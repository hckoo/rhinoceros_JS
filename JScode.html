<!DOCTYPE html>
<html>
<head>
<script type="text/javascript">

//4.4 프로퍼티 접근 표현식
// 131203



var o = { x : 1 , y : { z :3 }, "a" : 4};

var a = [o, 4 , [5, 6]];

log(o);		//Object {x: 1, y: Object, a: 4}
log(o.x);	//1
log(o.a); 	//4
// log(o."a"); 	// unexpect string
// log(o[x]); 	// undefind.
log(o["x"]); //1

log(a[2]["1"]);  //6
log(a[2][1]); // same. 6

log(a[0].x); // 1
log(a[1].x); //undefind.
log("toString --> "+a[1].toString()); // 4.
log("valueOf --> "+a[1].valueOf());	 // 4.


// 프로퍼티에 할당 하기. var 의 개념이 아니다..
a.smthing = 1;
log("something -->" + a.smthing); // 1.

// + 연산자의 동작.

log("100"+"100"); //100100
log("100"+100);	//100100	
log(100+100); //200
log(true+true); // 2


log(+"30"); //30
log(+"FF"); //NaN


// 동등 연산자
log("동등연산자...........");
log("0"==false); //true
log("0"===false); //false
log(false===false); //true

// 비교연산자.
log("비교연산자...........");
log("11"> 3); // true.
log("11"> "3"); // false.
log("b>a ===>"+("b">"a")); // true.
log("a">3); //false. NAN.


// in Operator
log("in Operator...........");
var point = { x: 1};
log("x" in  point); //true
// log(x in  point); // x is not defined
log("y" in  point); //false
log("toString" in  point); //true

//instanceof Operator
log("instanceof Operator...........");
var d = new Date();
log(d instanceof Object); //true
log(d instanceof Number); //false

// variable and Properties.
// 둘의 차이는 무엇인가?

// hiyo; // not defined 가 된다.
hi = "hi"; // this is OK.

second;
var second = 2; // 이 두문장은. OK second 가 not defined 라도 scope 내 var 가 존재하는것을 hoisting(?) 으로 찾아낸다.

log(acc); //undefined (no error)
var acc = 24;
// log(bcc); //ReferenceError: b is not defined
window.bcc = 36; // window 객체는 <script></scriipt> 내의 객체가 아님을 유의할것. 
// • Window 객체는 브라우저 창을 나타낸다.
// • 모든 자바스크립트 객체, 함수, 변수는 자동적으로 Window 객체의 멤버가 된다.
// • 전역 변수(global variable)는 Window 객체의 속성(property)이 된다.
// • 전역 함수(global function)은 Window 객체의 메소드(method)가 된다.
// • 하물며, HTML DOM의 Document 객체까지도 Window 객체의 속성(property)이 된다.
log(bcc); //36
log(window.hi); // hi.

// var x = { var x : 2}; //error // 사용자 객체 안에 객체를 선언하는것은 불가능하다..
// var y = [ var x ];  //error

//eval
log("eval ...........");
 var a = {
    b: function () {
      var foo = 'foo';
      return eval('foo'); // (A)
    },
    c: function () {
      return eval('this'); // (B)
    }
  };

  log(a.b()); //--> 'foo'
  log(a === a.c()); //--> true

    var foo = 'global_foo';

  function directEval() {
    var foo = 'local_foo';
    return eval('foo');
  }

  function indirectEval() {
    var foo = 'local_foo';
    var f = eval; // 직접 eval을 호출하지 않고 eval의 참조를 호출한다.
    return f('foo');
  }


  directEval(); //--> 'local_foo'
  indirectEval(); //--> 'global_foo'

  // infinite function with eval
  function infinite() {
    var f = eval; // 직접 eval을 호출하지 않고 eval의 참조를 호출한다.
    f(console.log("infinite!!!!!"));
    f('infinite();');
  }

  // this.infinite(); // diffiernt a bit.

  // infinite function.
  function infi2(){
  	console.log("infi2");
  	infi2();
  }

  // infi2();

log("typeof ...........");

log(typeof "3"); //string
log(typeof("3")); //string.
log(typeof 3); //number
log(typeof infi2); //function


// 배열내부 값들 넣기..

var o = { x : 10, y:20, z:30};
var a = [] , i = 0 , b = [];
for(a[i++] in o);
// for(i in a) console.log(i);
	var j = 0;
	for(var p in o){
		b[j]= o[p];
		j++;
		console.log(o[p]);
	}
// console.log(a);

// 모든객체는 Boolean 을 가지고 있다.
console.log(Boolean(null));
console.log(Boolean(1));
console.log(Boolean(2));
console.log(Boolean(0)); //false


function log(arg){
	console.log(arg);
}



</script>
	
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>
hi


</body>
</html>